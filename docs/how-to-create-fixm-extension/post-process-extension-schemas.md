# Post-Process the Extension Schemas

After the schemas have been generated they will need to be
post-processed. The post-processing script referenced in APPENDIX C will need to be modified in two ways in order to accommodate your Extension.

## Include Extension Namespace Prefix

FIXM standardly adds "Type" to the end of the name of all of the types
declared in its schemas. In order to avoid doing this to built-in XSD
types, the post-processing script uses namespace prefixes to determine
which types it should modify. To accommodate this, your Extension’s
namespace prefix needs to be added to the script for proper processing.

1. First, locate the else clause near the end of the script that
    contains the comment:

    ```perl
    # Add "Type" to the end of all FIXM type names (both declaration and use).
    ```

2. In this section, you will see a series of search and replace
    commands. The bottom three of these have a portion that lists out
    all the namespace prefix options used by the FIXM schemas as part of
    the search field. These lines need to be modified to include the
    namespace prefix used by your Extension.

    For the example created here, this change should be implemented as shown below (modification in red):

    ```perl
    $line =~ s/<xs:(restriction|extension).*base="(fb|fx|msg|xmp):[^"]*/$&Type/;
    $line =~ s/<xs:(attribute|element).*type="(fb|fx|msg|xmp):[^"]*/$&Type/;
    $line =~ s/<xs:list.*itemType="(fb|fx|msg|xmp):[^"]*/$&Type/;
    ```

## Set Up and Use Package-Wide Include Files

FIXM makes use of “package-wide include files” that increase its
usability with a number of XML tools. The schema files that will contain
the needed include elements are generated by Sparx EA but it is the
post-processing script that creates the actual include elements within
these files.

Depending on the complexity and structure of your Extension, you may
need many of these but you should always have at least one: the root
schema file corresponding to your Extension’s root package. In this
example, that is the “Example.xsd” file created by the Example package.

1. Directly above the section of the post-processing script referenced
    in the previous step (for adding “Type” to type names), locate the
    series of elsif clauses with conditionals along the lines of:

    ```perl
    elsif ($schema =~ /\/[filename].xsd/)
    ```

2. At the end of this section, directly after the closing brace of the
    last elsif clause in the series, add your own elsif clause for
    setting up your Extension’s root schema file. The conditional needs
    to be set up to match your root schema file’s name (in this example,
    “Example.xsd”).

3. In the body of the clause, add include elements for the schema files
    of each subcomponent in your Extension as well as an import element
    for the package-wide include file of every set of schemas you use
    with a different namespace then your extension’s own.

For the example created here, the new clause should look like this:

```perl
# Add package-wide includes to Example.xsd
elsif ($schema =~ /\/Example.xsd/)
{
  $line = "\t<xs:include schemaLocation=\"./ExampleEnRoute.xsd\"/>\n" .
          "\t<xs:include schemaLocation=\"./ExampleMessage.xsd\"/>\n" .
          "\t<xs:import namespace=\"http://www.fixm.aero/base/4.2\" schemaLocation=\"../../core/base/Base.xsd\"/>\n" .
          "\t<xs:import namespace=\"http://www.fixm.aero/flight/4.2\" schemaLocation=\"../../core/flight/Flight.xsd\"/>\n" .
          "\t<xs:import namespace=\"http://www.fixm.aero/app/msg/1.0\" schemaLocation=\"../../applications/basicmessage/BasicMessage.xsd\"/>\n" .
          $line;
}
```

Finally, as noted in APPENDIX C, be careful not to run your modified
post-processing script against any schema files that have already been
post-processed. To avoid this issue, either regenerate the Core and/or
Applications schemas you need before post-processing the entire schemas
directory or run the script exclusively against the generated Extension
schemas.
